---
title: "Resultados_V2"
author: "Jose Aguilar Milla"
output: html_document
date: "`r Sys.Date()`"
---

```{r setup, message=FALSE, warning=FALSE}
library(imager)
library(waveslim)
carpeta_clean <- "fotos_clean"
carpeta_ruido <- "fotos_ruido"

#asegurar 3 canales
to_rgb <- function(img){
  if (spectrum(img) == 1) {
    img <- imappend(list(img,img,img), axis = "c")
  }
  img
}


#  FUNCIONES DE JOAN tal cual


eliminate <- function(wR,wG,wB,mode) {
  
  if (mode == 'all') {
    
    for (j in 1:(length(wR)-1)) {
    
      wR[[j]] <- 0*wR[[j]]
      wG[[j]] <- 0*wG[[j]]
      wB[[j]] <- 0*wB[[j]]
    
    }
  }
  
  else if (mode == 'diag') {
    
    for (j in 1:(length(wR)-1)) {
      
      if (j %% 3 == 0) {
    
        wR[[j]] <- 0*wR[[j]]
        wG[[j]] <- 0*wG[[j]]
        wB[[j]] <- 0*wB[[j]]
      }
    }
    
  }
  
  return(list(R = wR,G = wG,B = wB))
}

plot_err <- function(img,img_noise,max_lev=8,wf='la8',mode = 'all') {
  
  R_T <- img[,,,1]
  G_T <- img[,,,2]
  B_T <- img[,,,3]
  
  R <- img_noise[,,,1]
  G <- img_noise[,,,2]
  B <- img_noise[,,,3]
  
  err <- c()
  
  for (i in 1:max_lev) {
    
    wR <- dwt.2d(R, wf = wf, J = i)
    wG <- dwt.2d(G, wf = wf, J = i)
    wB <- dwt.2d(B, wf = wf, J = i)
    
    res <- eliminate(wR,wG,wB,mode)
    
    wR <- res$R
    wG <- res$G
    wB <- res$B
    
    R_rec <- idwt.2d(wR)
    G_rec <- idwt.2d(wG)
    B_rec <- idwt.2d(wB)
      
    err_R <- sum((R_T-R_rec)**2)
    err_G <- sum((G_T-G_rec)**2)
    err_B <- sum((B_T-B_rec)**2)
    
    err[i] <- (1/(3*nrow(R)*ncol(R))*(err_R+err_G+err_B))**0.5
  }

  plot(1:max_lev, err, col = 'red', 
       xlab='Niveles de la DWT',ylab='RMSE', 
       main=paste0('Error en función del nivel para wf = ',wf, 
                   ' y modo = ', mode))
}

plot_comp <- function(img,img_noise,opt_lev, wf='la8', mode = 'all') {
  
  R <- img_noise[,,,1]
  G <- img_noise[,,,2]
  B <- img_noise[,,,3]
  
  wR <- dwt.2d(R, wf = wf, J = opt_lev)
  wG <- dwt.2d(G, wf = wf, J = opt_lev)
  wB <- dwt.2d(B, wf = wf, J = opt_lev)
    
  res <- eliminate(wR,wG,wB,mode)
    
  wR <- res$R
  wG <- res$G
  wB <- res$B
  
  R_rec <- idwt.2d(wR)
  G_rec <- idwt.2d(wG)
  B_rec <- idwt.2d(wB)
      
  img_rec <- imappend(list(as.cimg(R_rec), as.cimg(G_rec),
                         as.cimg(B_rec)), axis = "c")
  
  par(mfrow = c(2, 2), mar = c(1, 1, 1, 1))
  plot(img, main='Original',axes=FALSE)
  plot(img_noise, main='Con ruido',axes=FALSE)
  plot(img_rec, main= 'DWT óptima',axes=FALSE)
}


# Esto es lo mismo que la funcion de Joan de plot_err pero DEVUELVE err que nos hace falta más adelante

get_err <- function(img,img_noise,max_lev=8,wf='la8',mode='all') {
  
  R_T <- img[,,,1]; G_T <- img[,,,2]; B_T <- img[,,,3]
  R <- img_noise[,,,1]; G <- img_noise[,,,2]; B <- img_noise[,,,3]
  
  err <- numeric(max_lev)
  
  for (i in 1:max_lev) {
    wR <- dwt.2d(R, wf = wf, J = i)
    wG <- dwt.2d(G, wf = wf, J = i)
    wB <- dwt.2d(B, wf = wf, J = i)
    
    res <- eliminate(wR,wG,wB,mode)
    R_rec <- idwt.2d(res$R)
    G_rec <- idwt.2d(res$G)
    B_rec <- idwt.2d(res$B)
    
    err_R <- sum((R_T-R_rec)^2)
    err_G <- sum((G_T-G_rec)^2)
    err_B <- sum((B_T-B_rec)^2)
    
    err[i] <- sqrt((err_R + err_G + err_B)/(3*nrow(R)*ncol(R)))
  }
  
  err
}

# Parseo de nombres ruido -> base / noise
parse_noise_file <- function(path){
  name <- tools::file_path_sans_ext(basename(path))
  noise <- sub(".*_(gauss|sp|poisson|speckle)$", "\\1", name)
  base  <- sub("_(gauss|sp|poisson|speckle)$", "", name)
  list(base=base, noise=noise, name=name)
}

```

---

## 2) Batch: aplicar `plot_err`/`plot_comp` (con `opt_lev` calculado) a todas las imágenes

Este chunk hace exactamente esto para **cada imagen con ruido**:
- carga `clean` y `noisy`
- calcula `err_all` y `err_diag` con `get_err()`
- obtiene `opt_lev_all` y `opt_lev_diag`
- guarda una tabla de resultados (para luego comentar)
- (opcional) genera plots solo para una imagen “representativa” por ruido (para no inundar el HTML)

```{r}
max_lev <- 6
wf <- "la8"

files_ruido <- list.files(carpeta_ruido, pattern="\\.jpg$", full.names=TRUE, ignore.case=TRUE)

# Tabla donde guardaremos resultados por imagen-ruido
results <- data.frame(
  base=character(), noise=character(),
  opt_all=integer(), rmse_min_all=double(),
  opt_diag=integer(), rmse_min_diag=double(),
  stringsAsFactors = FALSE
)

for (f in files_ruido) {
  p <- parse_noise_file(f)
  f_clean <- file.path(carpeta_clean, paste0("clean_", p$base, ".jpg"))
  if (!file.exists(f_clean)) next
  
  img <- to_rgb(load.image(f_clean))
  img_noise <- to_rgb(load.image(f))
  
  # Curvas (numéricas) usando lo de Joan
  err_all  <- get_err(img, img_noise, max_lev=max_lev, wf=wf, mode="all")
  err_diag <- get_err(img, img_noise, max_lev=max_lev, wf=wf, mode="diag")
  
  # Nivel óptimo por modo
  opt_all  <- which.min(err_all)
  opt_diag <- which.min(err_diag)
  
  results <- rbind(
    results,
    data.frame(
      base=p$base, noise=p$noise,
      opt_all=opt_all,   rmse_min_all=min(err_all),
      opt_diag=opt_diag, rmse_min_diag=min(err_diag),
      stringsAsFactors = FALSE
    )
  )
}

results
```


---

## 3) Figuras: aplicar `plot_err` y `plot_comp` (1 ejemplo por ruido) + Guardado de los outputs

Como el informe normalmente no necesita 32×(varias figuras), este chunk elige:
- una `base_ej` (la primera que exista)
- y para cada ruido (`gauss, sp, poisson, speckle`) dibuja:
  1) `plot_err(... mode="all")`
  2) `plot_err(... mode="diag")`
  3) `plot_comp(... opt_lev_all, mode="all")`
  4) `plot_comp(... opt_lev_diag, mode="diag")`

```{r}
dir_out <- "resultados jose"
if (!dir.exists(dir_out)) dir.create(dir_out)

# En lugar de una sola base, iteramos por todas
bases <- unique(results$base)

for (base_ej in bases) {

  for (nz in c("gauss","sp","poisson","speckle")) {
    f_clean <- file.path(carpeta_clean, paste0("clean_", base_ej, ".jpg"))
    f_noisy <- file.path(carpeta_ruido, paste0(base_ej, "_", nz, ".jpg"))
    if (!file.exists(f_clean) || !file.exists(f_noisy)) next

    img <- to_rgb(load.image(f_clean))
    img_noise <- to_rgb(load.image(f_noisy))

    # Recuperar óptimos precalculados
    opt_all  <- results$opt_all [results$base==base_ej & results$noise==nz][1]
    opt_diag <- results$opt_diag[results$base==base_ej & results$noise==nz][1]

    oldpar <- par(no.readonly = TRUE)
    on.exit(par(oldpar), add = TRUE)

    # 1) Curva RMSE (all) - plot separado + ruido
    #jpg
    jpeg(file.path(dir_out, paste0(base_ej,"_",nz,"_rmse_all.jpg")),
         width=8, height=5, units="in", res=300)
      par(mfrow = c(1,1), mar = c(5,4,4,2) + 0.1, oma = c(0,0,2,0))
      plot_err(img, img_noise, max_lev = max_lev, wf = wf, mode = "all")
      mtext(paste0("Base: ", base_ej, " | Ruido: ", nz, " | Modo: all"),
            outer = TRUE, cex = 1)
    dev.off()

    #rmd
    par(mfrow = c(1,1), mar = c(5,4,4,2) + 0.1, oma = c(0,0,2,0))
    plot_err(img, img_noise, max_lev = max_lev, wf = wf, mode = "all")
    mtext(paste0("Base: ", base_ej, " | Ruido: ", nz, " | Modo: all"),
          outer = TRUE, cex = 1)


    # 2) Curva RMSE (diag) - plot separado + ruido
    #jpg
    jpeg(file.path(dir_out, paste0(base_ej,"_",nz,"_rmse_diag.jpg")),
         width=8, height=5, units="in", res=300)
      par(mfrow = c(1,1), mar = c(5,4,4,2) + 0.1, oma = c(0,0,2,0))
      plot_err(img, img_noise, max_lev = max_lev, wf = wf, mode = "diag")
      mtext(paste0("Base: ", base_ej, " | Ruido: ", nz, " | Modo: diag"),
            outer = TRUE, cex = 1)
    dev.off()

    #rmd
    par(mfrow = c(1,1), mar = c(5,4,4,2) + 0.1, oma = c(0,0,2,0))
    plot_err(img, img_noise, max_lev = max_lev, wf = wf, mode = "diag")
    mtext(paste0("Base: ", base_ej, " | Ruido: ", nz, " | Modo: diag"),
          outer = TRUE, cex = 1)


    # 3) Comparación (all) - plot separado + ruido y modo
    par(oldpar)
    #jpg
    jpeg(file.path(dir_out, paste0(base_ej,"_",nz,"_comp_all.jpg")),
         width=8, height=6, units="in", res=300)
      par(oma = c(0,0,2,0))
      plot_comp(img, img_noise, opt_lev = opt_all, wf = wf, mode = "all")
      mtext(paste0("Base: ", base_ej, " | Ruido: ", nz, " | Modo: all | opt_lev: ", opt_all),
            outer = TRUE, cex = 1)
    dev.off()

    #rmd
    par(oma = c(0,0,2,0))
    plot_comp(img, img_noise, opt_lev = opt_all, wf = wf, mode = "all")
    mtext(paste0("Base: ", base_ej, " | Ruido: ", nz, " | Modo: all | opt_lev: ", opt_all),
          outer = TRUE, cex = 1)


    # 4) Comparación (diag) - plot separado + ruido y modo
    par(oldpar)
    #jpg
    jpeg(file.path(dir_out, paste0(base_ej,"_",nz,"_comp_diag.jpg")),
         width=8, height=6, units="in", res=300)
      par(oma = c(0,0,2,0))
      plot_comp(img, img_noise, opt_lev = opt_diag, wf = wf, mode = "diag")
      mtext(paste0("Base: ", base_ej, " | Ruido: ", nz, " | Modo: diag | opt_lev: ", opt_diag),
            outer = TRUE, cex = 1)
    dev.off()

    #rmd
    par(oma = c(0,0,2,0))
    plot_comp(img, img_noise, opt_lev = opt_diag, wf = wf, mode = "diag")
    mtext(paste0("Base: ", base_ej, " | Ruido: ", nz, " | Modo: diag | opt_lev: ", opt_diag),
          outer = TRUE, cex = 1)
  }

}

```

```{r}
# CONFIGURACIÓN
target_base <- "objeto_vaca"  # El nombre clave de tu imagen (sin "clean_")
wf <- "la8"
max_lev <- 6

# 1. Buscamos TODOS los archivos de ruido
all_files <- list.files(carpeta_ruido, pattern="\\.jpg$", full.names=TRUE, ignore.case=TRUE)

# 2. Filtramos: Nos quedamos SOLO con los archivos que contengan "objeto_vaca" en el nombre
# (Esto asume que el archivo de ruido lleva el nombre de la imagen original dentro)
files_vaca <- all_files[grep(target_base, all_files)]

# Tabla para guardar resultados
results_vaca <- data.frame(
  ruido = character(),
  opt_level = integer(),
  rmse_min = double(),
  stringsAsFactors = FALSE
)

# 3. Procesamos
for (f in files_vaca) {
  
  # Extraemos info del nombre (asumiendo que tienes tu función parse_noise_file)
  p <- parse_noise_file(f)
  
  # Verificación extra: si por algún motivo p$base no coincide, saltamos
  if (p$base != target_base) next
  
  # Buscamos la original limpia
  f_clean <- file.path(carpeta_clean, paste0("clean_", target_base, ".jpg"))
  
  if (!file.exists(f_clean)) {
    message(paste("No encuentro la imagen limpia:", f_clean))
    next
  }
  
  # Cargar imágenes
  img <- to_rgb(load.image(f_clean))
  img_noise <- to_rgb(load.image(f))
  
  # 4. Calculamos SOLO la estrategia "ALL"
  err_all <- get_err(img, img_noise, max_lev=max_lev, wf=wf, mode="all")
  
  # Sacamos los datos
  opt_level <- which.min(err_all)
  min_rmse  <- min(err_all)
  
  # Guardamos
  results_vaca <- rbind(results_vaca, data.frame(
    ruido = p$noise,       # El tipo de ruido (gauss, speckle, etc.)
    opt_level = opt_level,
    rmse_min = min_rmse,
    stringsAsFactors = FALSE
  ))
}

# Mostramos la tabla ordenada
knitr::kable(results_vaca, caption = paste("Resultados para", target_base, "con estrategia 'ALL'"))
```
```{r}
# --- CONFIGURACIÓN ---
# 1. Definimos las imágenes exactas que quieres comparar
mis_imagenes <- c("cielo_noche_arboles", "cielo_noche")

# 2. Definimos el ruido que buscamos (ajusta "sp" si en tus archivos se llama "s&p")
mi_ruido <- "sp" 

wf <- "la8"
max_lev <- 6

# 3. Preparamos la tabla para guardar resultados comparativos
results_cielo <- data.frame(
  Imagen = character(),
  Ruido = character(),
  RMSE_All = double(),
  RMSE_Diag = double(),
  Mejor_Metodo = character(), # Para ver cuál gana automáticamente
  stringsAsFactors = FALSE
)

# Listamos todos los archivos ruidosos una vez
all_files <- list.files(carpeta_ruido, pattern="\\.jpg$", full.names=TRUE, ignore.case=TRUE)

# --- BUCLE PRINCIPAL ---
for (base_name in mis_imagenes) {
  
  # A. Buscar el archivo ruidoso que coincida con el nombre y el tipo de ruido
  # Filtramos primero por el nombre de la imagen
  candidates <- all_files[grep(base_name, all_files)]
  # Filtramos después por el tipo de ruido
  f_ruido <- candidates[grep(mi_ruido, candidates)]
  
  # Si encuentra más de uno o ninguno, avisamos y saltamos
  if (length(f_ruido) == 0) {
    message(paste("⚠️ No encuentro archivo con ruido", mi_ruido, "para", base_name))
    next
  }
  # Nos quedamos con el primero que coincida (por seguridad)
  f_ruido <- f_ruido[1]
  
  # B. Buscar imagen limpia
  f_clean <- file.path(carpeta_clean, paste0("clean_", base_name, ".jpg"))
  
  if (!file.exists(f_clean)) {
    message(paste("⚠️ No existe la imagen limpia:", f_clean))
    next
  }
  
  # C. Cargar imágenes
  img <- to_rgb(load.image(f_clean))
  img_noise <- to_rgb(load.image(f_ruido))
  
  # D. Calcular errores para AMBOS métodos
  # 1. Método ALL
  err_all <- get_err(img, img_noise, max_lev=max_lev, wf=wf, mode="all")
  min_rmse_all <- min(err_all)
  
  # 2. Método DIAG
  err_diag <- get_err(img, img_noise, max_lev=max_lev, wf=wf, mode="diag")
  min_rmse_diag <- min(err_diag)
  
  # E. Determinar ganador
  ganador <- ifelse(min_rmse_diag < min_rmse_all, "DIAG", "ALL")
  
  # F. Guardar fila
  results_cielo <- rbind(results_cielo, data.frame(
    Imagen = base_name,
    Ruido = mi_ruido,
    RMSE_All = round(min_rmse_all, 4),   # Redondeamos a 4 decimales
    RMSE_Diag = round(min_rmse_diag, 4),
    Mejor_Metodo = ganador,
    stringsAsFactors = FALSE
  ))
}

# --- GUARDAR Y MOSTRAR ---

# 1. Guardar como PNG GRANDE (para que se vea bien)
library(gridExtra)
library(grid)

ruta_salida <- file.path("resultados jose", "tabla_cielo_sp.png")

# Ajustamos tamaño y letra
png(ruta_salida, width = 800, height = 300) 
tt <- ttheme_default(base_size = 16) # Letra grande
grid.table(results_cielo, rows = NULL, theme = tt)
dev.off()

# 2. Mostrar la tabla en pantalla (RMarkdown)
knitr::kable(results_cielo, caption = "Comparativa Cielo Nocturno con Ruido S&P")

# 1. LIMPIEZA PREVIA (Por si se quedó algo atascado)
while (!is.null(dev.list())) dev.off()

# 2. ASEGURAR QUE LA CARPETA EXISTE
nombre_carpeta <- "resultados jose"
if (!dir.exists(nombre_carpeta)) {
  dir.create(nombre_carpeta)
  message(paste("He creado la carpeta:", nombre_carpeta))
}

# 3. GUARDAR LA TABLA
library(gridExtra)
library(grid)

# Definimos el nombre del archivo
ruta_archivo <- file.path(nombre_carpeta, "tabla_conclusiones.png")

# Abrimos el "lienzo"
png(ruta_archivo, height = 400, width = 600)

# Dibujamos
grid.table(results_vaca) # Asegúrate de que tu tabla se llama 'results_vaca'

# Cerramos para guardar
dev.off()

message(paste("✅ ¡Listo! Tabla guardada en:", ruta_archivo))
```


```{r}

library(ggplot2)
library(dplyr)
library(tidyr)

# 1. PREPARACIÓN DE LOS DATOS
# Tomamos tu tabla 'results', agrupamos por ruido y calculamos la media
datos_grafico <- results %>%
  group_by(noise) %>%
  summarise(
    # Calculamos el promedio para cada estrategia
    All = mean(rmse_min_all, na.rm = TRUE),
    Diag = mean(rmse_min_diag, na.rm = TRUE)
  ) %>%
  # Pasamos a formato largo para ggplot (creamos columnas "Estrategia" y "Error")
  pivot_longer(
    cols = c("All", "Diag"),
    names_to = "Estrategia",
    values_to = "RMSE_Promedio"
  )

# 2. CREACIÓN DEL GRÁFICO
ggplot(datos_grafico, aes(x = noise, y = RMSE_Promedio, fill = Estrategia)) +
  # geom_col crea las barras. position = "dodge" las pone una al lado de la otra
  geom_col(position = "dodge", width = 0.7, color = "black") + 
  
  # Añadimos etiquetas de texto encima de las barras (opcional, para ver el valor exacto)
  geom_text(aes(label = round(RMSE_Promedio, 2)), 
            position = position_dodge(width = 0.7), 
            vjust = -0.5, size = 3.5) +
  
  # Personalización de colores y estilo
  scale_fill_manual(values = c("All" = "#4E84C4", "Diag" = "#D16103")) + # Azul y Naranja
  theme_minimal() +
  labs(
    title = "Comparativa de Error Promedio (RMSE) por Tipo de Ruido",
    subtitle = "Estrategia 'All' vs 'Diag'",
    x = "Tipo de Ruido",
    y = "RMSE Promedio",
    fill = "Estrategia"
  ) +
  theme(
    legend.position = "top", # Leyenda arriba
    axis.text.x = element_text(size = 11, face = "bold"),
    plot.title = element_text(hjust = 0.5) # Centrar título
  )



# 1. Definir dónde lo vamos a guardar
carpeta_destino <- "resultados jose"
nombre_archivo <- "grafico_comparativa_rmse.jpg"
ruta_completa <- file.path(carpeta_destino, nombre_archivo)

# 2. Asegurar que la carpeta existe (por si acaso)
if (!dir.exists(carpeta_destino)) {
  dir.create(carpeta_destino)
}

# 3. Guardar el gráfico
# ggsave coge automáticamente el último gráfico generado por ggplot.
# - width y height: El tamaño en pulgadas (puedes cambiarlo si lo quieres más ancho/alto).
# - dpi = 300: "Puntos por pulgada". 300 es calidad de impresión estándar (para que no se vea borroso).
ggsave(
  filename = ruta_completa,
  width = 8,       # Ancho en pulgadas
  height = 5,      # Alto en pulgadas
  units = "in",
  dpi = 300        # Alta resolución
)

message(paste("✅ Gráfico guardado con éxito en:", ruta_completa))
```



